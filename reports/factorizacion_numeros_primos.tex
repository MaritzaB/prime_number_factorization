\documentclass{article}
\usepackage{csvsimple}
\usepackage{float}
\usepackage{booktabs}
\usepackage{pgfplotstable}
\usepackage{caption}
%\usepackage{pythontex}
\usepackage{hyperref}
\usepackage[spanish,es-tabla,es-nodecimaldot]{babel}
\usepackage{multirow}
\usepackage[a4paper,top=1cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry} 
%\pgfplotstableread[col sep=comma]{tables/resumen_cinco_numero_serpientes.csv}\ResumenCincoNumeros


\begin{document}
\title{Factorización de números primos}
\author{Ana Maritza Bello Yañez}
\maketitle

\section{Descripción del problema}
% ¿Qué se quiere hacer?

\section{Justificación del problema}
% ¿Por qué es importante resolver este problema?

\section{Estado del arte}
% Qué se ha hecho hasta ahora?

¿Cómo se analiza el rendimiento en el tiempo de ejecución?

Para 


\section{Solución}
% ¿Cómo se piensa resolver este problema?

\section{Resultados y conclusiones}

TEOREMA:
La descomposición en primos de cualquier entero positivo mayor que 1 es única,
excepto por el orden en que se escriben los factores primos \cite{lewinter2015elementary}.

La descomposición en factores primos es un concepto de la teoría de números que
se refiere a la descomposición de un número en el producto de dos números
primos. La factorización prima es un subconjunto de la factorización de enteros,
en la que un número compuesto se factoriza en el producto de dos enteros
cualesquiera.

Es un desafío encontrar los factores de los semiprimos (números que resultan del
producto de dos números primos) porque tienen solo un par de factores, y la
complejidad de encontrar los factores aumenta a medida que el tamaño del número
primo se usa en el producto aumenta. No existe un algoritmo de factorización
eficiente conocido para encontrar factores cuando los números son de cierto
tamaño. RSA usa factorización prima, suponiendo que es realmente difícil
encontrar la clave privada del producto expuesto de números primos. Esta
supuesta dificultad es la razón detrás del uso de la factorización prima en
criptografía \cite{raj2019foundations}.

criptosistema RSA \cite{raj2019foundations}.
RSA es una de las implementaciones iniciales de criptografía público-privada.
Utiliza el principio de factorización prima para generar un par de claves
pública-privada, que actúa como una función de trampilla. El cifrado se realiza
con la clave pública, que se distribuye a todo el mundo, y el descifrado se
realiza con la clave privada guardada en secreto.

La idea de un criptosistema de clave pública-privada asimétrica se atribuye a
Whitfield Diffie y Martin Hellman, quienes publicaron este concepto en 1976.


El par de claves pública y privada se calculan con la ayuda de dos grandes
números primos. La clave pública se publica para el usuario y la clave privada
se mantiene en secreto. Los números primos también se mantienen en secreto.
Siempre que los números primos utilizados sean grandes, no es factible calcular
la clave privada a partir de la clave pública. Todo el criptosistema RSA se basa
en el problema de la teoría de números de la factorización de enteros, lo que
garantiza que la dificultad de la factorización prima sea proporcional al tamaño
de los números primos utilizados.


¿Cómo analiza el rendimiento del tiempo de ejecución de este algoritmo? 

Para la mayoría de los algoritmos, considera el tiempo de ejecución como una
función de la cantidad de entradas. Sin embargo, este algoritmo solo tiene una
entrada: el número que está factorizando. El algoritmo tarda más en factorizar
números grandes, por lo que no tiene sentido pensar en la cantidad de tiempo que
tarda el algoritmo en función del valor 1. 

Para algoritmos como este, el tiempo
depende del tamaño de la entrada y no en el número de entradas. Así es como los
analiza: observando el tamaño de la entrada. Puede pensar en esto como mirar la
cantidad de bits en el valor que va a factorizar. Ignora cualquier bit de orden
superior que sea cero. 

Por ejemplo, el valor 1, almacenado en un entero de 64
bits, aún ocupa 64 bits en la computadora. Pero en realidad solo estamos
interesados en ese único bit que realmente usa el valor 1. Se necesitan bits
Log n para representar el número n en binario. Aquí estoy usando n minúscula
para recordar que estamos hablando del valor de la entrada y no del número de
entradas. Si dejamos que N mayúscula sea el número de bits, entonces tenemos
esta ecuación: la base logarítmica 2 de n pequeña es igual a N mayúscula. Si
reorganizamos eso un poco, puede obtener esto: para n pequeña en términos de N
mayúscula. Ahora, ¿qué podemos decir sobre el tiempo de ejecución del algoritmo
de factorización? El peor caso para este algoritmo ocurre cuando el número de
entrada es primo. En ese caso, el programa examina posibles factores impares
hasta llegar a la raíz cuadrada del número. El número de pasos que realiza para
llegar a ese punto es la raíz cuadrada del número. Eso significa que el tiempo
de ejecución del algoritmo es la raíz cuadrada del orden de n minúscula. Para
convertir eso en una función que involucre el número de bits, N mayúscula,
reemplazamos la n minúscula con esta ecuación que encontramos anteriormente. El
resultado es que el tiempo de ejecución del algoritmo es raíz cuadrada del orden
de 2 elevado a n. Podemos simplificar eso un poco, porque la raíz cuadrada de 2
elevado a n es lo mismo que la raíz cuadrada de 2 elevado a n. Esto significa
que el tiempo de ejecución del algoritmo es exponencial en el número de bits de
entrada. Su tiempo de ejecución depende de potencias de la raíz cuadrada de 2,
por lo que no crece tan rápido como lo haría si dependiera de potencias de 2 o
algún número mayor. Pero una vez que la función crece, realmente despega, como
lo hacen todas las funciones exponenciales. Es por eso que este algoritmo
funciona para números moderadamente grandes pero no es práctico para números muy
grandes de 100 dígitos. Puede usar técnicas similares de usar bits de entrada
para analizar otros algoritmos que tienen un número fijo de entradas \cite{stephens2015learning}.



\bibliography{../references/references.bib} 
\bibliographystyle{apalike}

Ejemplo de ecuacion
$$ e^{i\pi} + 1 = 0 $$

\end{document}